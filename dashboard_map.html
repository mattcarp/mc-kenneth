<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Kenneth â€” AIS Vessel Tracker & Voice Correlation</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/wavesurfer.js@7/dist/wavesurfer.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.8/dist/chart.umd.min.js"></script>

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: 'Courier New', monospace;
      background: #0d1117;
      color: #c9d1d9;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      background: #161b22;
      border-bottom: 1px solid #30363d;
      padding: 12px 20px;
      display: flex;
      align-items: center;
      gap: 16px;
      flex-shrink: 0;
    }

    header h1 { font-size: 1.1rem; color: #58a6ff; }
    header .subtitle { font-size: 0.75rem; color: #8b949e; }

    .status-bar {
      margin-left: auto;
      display: flex;
      gap: 16px;
      font-size: 0.75rem;
      align-items: center;
    }

    .status-dot {
      width: 8px; height: 8px;
      border-radius: 50%;
      display: inline-block;
      margin-right: 4px;
    }
    .dot-green { background: #3fb950; animation: pulse 2s infinite; }
    .dot-orange { background: #f78166; }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.4; }
    }

    .main {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    #map {
      flex: 1;
      background: #0d1117;
    }

    .sidebar {
      width: 320px;
      background: #161b22;
      border-left: 1px solid #30363d;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      flex-shrink: 0;
    }

    .sidebar-section {
      border-bottom: 1px solid #30363d;
      padding: 12px 16px;
    }

    .sidebar-section h2 {
      font-size: 0.8rem;
      color: #8b949e;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      margin-bottom: 8px;
    }

    .vessel-list {
      flex: 1;
      overflow-y: auto;
    }

    .vessel-card {
      padding: 10px 16px;
      border-bottom: 1px solid #21262d;
      cursor: pointer;
      transition: background 0.15s;
    }

    .vessel-card:hover { background: #1c2128; }
    .vessel-card.correlated { border-left: 3px solid #f78166; }

    .vessel-name {
      font-size: 0.85rem;
      color: #e6edf3;
      font-weight: bold;
    }

    .vessel-meta {
      font-size: 0.72rem;
      color: #8b949e;
      margin-top: 2px;
    }

    .corr-badge {
      display: inline-block;
      background: #f78166;
      color: #0d1117;
      font-size: 0.65rem;
      padding: 1px 5px;
      border-radius: 3px;
      margin-left: 6px;
      font-weight: bold;
    }

    .voice-list {
      flex: 0 0 auto;
      max-height: 360px;
      overflow-y: auto;
    }

    .voice-card {
      padding: 8px 16px;
      border-bottom: 1px solid #21262d;
      font-size: 0.72rem;
    }

    .voice-card .ts { color: #8b949e; }
    .voice-card .freq { color: #58a6ff; }
    .voice-card .meta-row {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      margin: 3px 0 6px 0;
    }
    .stress-badge {
      background: #30363d;
      border: 1px solid #484f58;
      border-radius: 3px;
      color: #c9d1d9;
      font-size: 0.62rem;
      padding: 1px 6px;
      white-space: nowrap;
    }
    .audio-controls {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-top: 6px;
      width: 100%;
    }
    .audio-controls button {
      background: #21262d;
      color: #c9d1d9;
      border: 1px solid #30363d;
      border-radius: 4px;
      font-size: 0.66rem;
      padding: 3px 8px;
      cursor: pointer;
    }
    .audio-controls button:hover {
      background: #30363d;
    }
    .audio-controls input[type="range"] {
      flex: 1;
      accent-color: #58a6ff;
    }
    .audio-time {
      color: #8b949e;
      font-size: 0.62rem;
      min-width: 70px;
      text-align: right;
      font-variant-numeric: tabular-nums;
    }
    .waveform {
      margin-top: 6px;
      border: 1px solid #30363d;
      border-radius: 4px;
      overflow: hidden;
      background: #0f141b;
      min-height: 68px;
    }
    .waveform.empty {
      min-height: 28px;
      padding: 6px 8px;
      color: #8b949e;
      font-size: 0.66rem;
      border-style: dashed;
    }
    .timeline-wrap {
      padding-top: 4px;
    }
    .timeline-empty {
      color: #8b949e;
      font-size: 0.7rem;
      margin-top: 6px;
    }

    .stat { display: flex; justify-content: space-between; font-size: 0.75rem; margin: 3px 0; }
    .stat-val { color: #58a6ff; }

    #refresh-countdown {
      font-size: 0.72rem;
      color: #8b949e;
    }

    /* Leaflet custom markers */
    .vessel-icon {
      background: #1f6feb;
      border: 2px solid #58a6ff;
      border-radius: 50%;
      width: 14px !important;
      height: 14px !important;
      margin-left: -7px !important;
      margin-top: -7px !important;
    }

    .vessel-icon.correlated {
      background: #f78166;
      border-color: #ff7b72;
    }

    .voice-icon {
      background: #388bfd22;
      border: 2px dashed #388bfd;
      border-radius: 50%;
    }
  </style>
</head>
<body>

<header>
  <div>
    <h1>ðŸš¢ Kenneth â€” AIS Vessel Tracker</h1>
    <div class="subtitle">Malta / Central Mediterranean Â· pyais decoder</div>
  </div>
  <div class="status-bar">
    <span><span class="status-dot dot-green"></span>Live</span>
    <span id="vessel-count">â€”</span>
    <span id="refresh-countdown">Refresh in 10s</span>
  </div>
</header>

<div class="main">
  <div id="map"></div>

  <div class="sidebar">
    <!-- Stats -->
    <div class="sidebar-section">
      <h2>Overview</h2>
      <div class="stat"><span>Vessels tracked</span><span class="stat-val" id="stat-vessels">â€”</span></div>
      <div class="stat"><span>Correlated captures</span><span class="stat-val" id="stat-correlated">â€”</span></div>
      <div class="stat"><span>Voice captures</span><span class="stat-val" id="stat-voices">â€”</span></div>
      <div class="stat"><span>Last update</span><span class="stat-val" id="stat-updated">â€”</span></div>
    </div>

    <!-- Voice Captures -->
    <div class="sidebar-section">
      <h2>Stress Timeline</h2>
      <div class="timeline-wrap">
        <canvas id="stress-timeline" height="130"></canvas>
        <div class="timeline-empty" id="timeline-empty">No stress datapoints yet.</div>
      </div>
    </div>

    <!-- Voice Captures -->
    <div class="sidebar-section">
      <h2>Recent Voice Captures</h2>
    </div>
    <div class="voice-list" id="voice-list">
      <div class="voice-card" style="color:#8b949e;font-size:0.72rem;padding:12px 16px;">
        No voice captures loaded. API at /voice/speakers returns profiles.
      </div>
    </div>

    <!-- Vessel List -->
    <div class="sidebar-section">
      <h2>Vessels</h2>
    </div>
    <div class="vessel-list" id="vessel-list">
      <div style="padding:12px 16px;color:#8b949e;font-size:0.75rem;">Loadingâ€¦</div>
    </div>
  </div>
</div>

<script>
// â”€â”€ Config â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const API_BASE      = window.location.origin;
const AIS_URL       = `${API_BASE}/maritime/ais`;
const ALERTS_URL    = `${API_BASE}/alerts?limit=50`;
const REFRESH_MS    = 10_000;
const CORR_TIME_MIN = 5;          // minutes for voiceâ†’vessel time window
const CORR_DIST_KM  = 50;         // km for voiceâ†’vessel distance window

// â”€â”€ Map Init â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const map = L.map('map', { zoomControl: true }).setView([35.9, 14.51], 9);

L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: 'Â© OpenStreetMap contributors',
  maxZoom: 18,
}).addTo(map);

// Leaflet layer groups
const vesselLayer = L.layerGroup().addTo(map);
const voiceLayer  = L.layerGroup().addTo(map);

// â”€â”€ Haversine distance (km) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function haversine(lat1, lon1, lat2, lon2) {
  const R = 6371;
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = Math.sin(dLat/2)**2 +
            Math.cos(lat1*Math.PI/180) * Math.cos(lat2*Math.PI/180) * Math.sin(dLon/2)**2;
  return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

// â”€â”€ Voice capture store â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Populated from /alerts â€” we treat marine-VHF alerts as voice proxies.
let voiceCaptures = [];
const voiceWaveforms = new Map();
let stressTimelineChart = null;

function clamp(v, min, max) {
  return Math.max(min, Math.min(max, v));
}

function parseTimestamp(value) {
  const dt = value ? new Date(value) : null;
  if (!dt || Number.isNaN(dt.getTime())) return new Date();
  return dt;
}

function formatTimecode(seconds) {
  if (!Number.isFinite(seconds) || seconds < 0) return '00:00';
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
}

function formatTimestampUTC(date) {
  return `${date.toISOString().replace('T', ' ').slice(0, 19)} UTC`;
}

function readStressScore(alert) {
  const md = alert.metadata || {};
  const candidates = [
    md.stress_score,
    md.stress_level,
    md.stress,
    md.emotions?.stress_level,
    alert.stress_level,
  ];

  for (const raw of candidates) {
    const numeric = Number(raw);
    if (Number.isFinite(numeric)) {
      const normalized = numeric <= 1 ? numeric * 100 : numeric;
      return Math.round(clamp(normalized, 0, 100));
    }
  }
  return null;
}

function resolveAudioUrl(rawAudioUrl) {
  if (!rawAudioUrl || typeof rawAudioUrl !== 'string') return null;
  if (rawAudioUrl.startsWith('http://') || rawAudioUrl.startsWith('https://') || rawAudioUrl.startsWith('/')) {
    return rawAudioUrl;
  }
  const filename = rawAudioUrl.split('/').pop();
  return filename ? `/api/audio/${encodeURIComponent(filename)}` : null;
}

async function fetchVoiceCaptures() {
  try {
    const r = await fetch(ALERTS_URL);
    if (!r.ok) return;
    const data = await r.json();
    const alerts = Array.isArray(data) ? data : (data.alerts || []);

    // Filter alerts tagged as marine voice captures
    voiceCaptures = alerts.filter(a =>
      a.signal_type === 'marine_vhf' || (a.tags || []).includes('voice')
    ).map(a => ({
      id: a.id,
      timestamp: parseTimestamp(a.created_at || a.timestamp),
      freq_mhz: a.frequency_mhz,
      title: a.title,
      lat: a.metadata?.lat ?? a.lat ?? null,   // may not be present
      lon: a.metadata?.lon ?? a.lon ?? null,
      stress: readStressScore(a),
      audio_url: resolveAudioUrl(a.audio_url || a.metadata?.audio_url),
    }));
  } catch (_) {
    // API unavailable â€” leave voiceCaptures as-is
  }
}

// â”€â”€ Correlation logic â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function correlate(vessel, captures) {
  if (vessel.lat == null || vessel.lon == null) return [];
  const vesselTime = new Date(vessel.timestamp);
  return captures.filter(cap => {
    const timeDiff = Math.abs(vesselTime - cap.timestamp) / 60000; // minutes
    if (timeDiff > CORR_TIME_MIN) return false;
    if (cap.lat != null && cap.lon != null) {
      const dist = haversine(vessel.lat, vessel.lon, cap.lat, cap.lon);
      return dist <= CORR_DIST_KM;
    }
    // If no position on capture, time-only correlation still flags it
    return timeDiff <= CORR_TIME_MIN;
  });
}

// â”€â”€ Render â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderVessels(vessels) {
  vesselLayer.clearLayers();
  const listEl = document.getElementById('vessel-list');
  listEl.innerHTML = '';

  let corrCount = 0;

  vessels.forEach(v => {
    if (v.lat == null || v.lon == null) return;

    const corr = correlate(v, voiceCaptures);
    const isCorr = corr.length > 0;
    if (isCorr) corrCount++;

    // Map marker
    const icon = L.divIcon({
      className: '',
      html: `<div class="vessel-icon${isCorr ? ' correlated' : ''}"></div>`,
      iconSize: [14, 14],
    });

    const popup = `
      <b>${v.name}</b><br/>
      MMSI: ${v.mmsi}<br/>
      ${v.speed_knots != null ? `Speed: ${v.speed_knots.toFixed(1)} kn` : ''}<br/>
      ${v.course != null ? `Course: ${v.course.toFixed(0)}Â°` : ''}<br/>
      ${v.nav_status ? `Status: ${v.nav_status}` : ''}<br/>
      ${isCorr ? `<span style="color:#f78166">âš  ${corr.length} voice capture(s) nearby</span>` : ''}
      <br/><small>${v.timestamp}</small>
    `;

    L.marker([v.lat, v.lon], { icon })
      .bindPopup(popup)
      .addTo(vesselLayer);

    // Sidebar card
    const card = document.createElement('div');
    card.className = `vessel-card${isCorr ? ' correlated' : ''}`;
    card.innerHTML = `
      <div class="vessel-name">
        ${v.name}
        ${isCorr ? `<span class="corr-badge">VOICE Ã—${corr.length}</span>` : ''}
      </div>
      <div class="vessel-meta">
        MMSI ${v.mmsi} Â·
        ${v.lat.toFixed(4)}Â°N ${v.lon.toFixed(4)}Â°E Â·
        ${v.speed_knots != null ? v.speed_knots.toFixed(1) + ' kn' : 'â€”'}
      </div>
    `;
    card.onclick = () => map.setView([v.lat, v.lon], 12);
    listEl.appendChild(card);
  });

  document.getElementById('stat-vessels').textContent = vessels.length;
  document.getElementById('stat-correlated').textContent = corrCount;
  document.getElementById('vessel-count').textContent = `${vessels.length} vessels`;
}

function renderVoiceCaptures() {
  const listEl = document.getElementById('voice-list');
  listEl.innerHTML = '';
  document.getElementById('stat-voices').textContent = voiceCaptures.length;

  if (!voiceCaptures.length) {
    listEl.innerHTML = `<div class="voice-card" style="color:#8b949e;">No marine-VHF captures in alert log.</div>`;
    return;
  }

  const captures = voiceCaptures.slice(0, 20);
  captures.forEach((cap, idx) => {
    const card = document.createElement('div');
    card.className = 'voice-card';
    const stressLabel = cap.stress == null ? 'Stress: N/A' : `Stress: ${cap.stress}/100`;
    const clipId = `clip-${cap.id || idx}`;
    const waveformId = `wave-${cap.id || idx}`;
    card.innerHTML = `
      <div class="freq">ðŸ“» ${cap.freq_mhz ? cap.freq_mhz.toFixed(3) + ' MHz' : 'Marine VHF'}</div>
      <div>${cap.title}</div>
      <div class="meta-row">
        <div class="ts">${formatTimestampUTC(cap.timestamp)}</div>
        <span class="stress-badge">${stressLabel}</span>
      </div>
    `;

    if (cap.audio_url) {
      card.insertAdjacentHTML('beforeend', `
        <audio id="${clipId}" src="${cap.audio_url}" preload="metadata"></audio>
        <div id="${waveformId}" class="waveform"></div>
        <div class="audio-controls">
          <button type="button" data-action="play">Play</button>
          <button type="button" data-action="pause">Pause</button>
          <input type="range" min="0" max="100" value="0" step="0.1" />
          <span class="audio-time">00:00 / 00:00</span>
        </div>
      `);
    } else {
      card.insertAdjacentHTML('beforeend', `<div class="waveform empty">No audio clip attached to this alert.</div>`);
    }

    listEl.appendChild(card);

    if (cap.audio_url) {
      setupAudioControls(card, clipId, waveformId);
    }
  });

  renderStressTimeline(voiceCaptures);
}

function setupAudioControls(card, clipId, waveformId) {
  const audio = card.querySelector(`#${clipId}`);
  const waveformContainer = card.querySelector(`#${waveformId}`);
  const playBtn = card.querySelector('button[data-action="play"]');
  const pauseBtn = card.querySelector('button[data-action="pause"]');
  const slider = card.querySelector('input[type="range"]');
  const timeEl = card.querySelector('.audio-time');

  if (!audio || !playBtn || !pauseBtn || !slider || !timeEl) return;

  playBtn.addEventListener('click', () => audio.play());
  pauseBtn.addEventListener('click', () => audio.pause());

  slider.addEventListener('input', () => {
    if (!Number.isFinite(audio.duration) || audio.duration <= 0) return;
    audio.currentTime = (Number(slider.value) / 100) * audio.duration;
  });

  const refreshUi = () => {
    const duration = Number.isFinite(audio.duration) ? audio.duration : 0;
    const current = Number.isFinite(audio.currentTime) ? audio.currentTime : 0;
    slider.value = duration > 0 ? ((current / duration) * 100).toFixed(2) : '0';
    timeEl.textContent = `${formatTimecode(current)} / ${formatTimecode(duration)}`;
  };

  audio.addEventListener('loadedmetadata', refreshUi);
  audio.addEventListener('timeupdate', refreshUi);
  audio.addEventListener('ended', refreshUi);

  if (waveformContainer && window.WaveSurfer) {
    const existing = voiceWaveforms.get(waveformId);
    if (existing) {
      existing.destroy();
      voiceWaveforms.delete(waveformId);
    }
    try {
      const ws = WaveSurfer.create({
        container: waveformContainer,
        media: audio,
        height: 66,
        waveColor: '#5d738a',
        progressColor: '#58a6ff',
        cursorColor: '#f78166',
        barWidth: 2,
        barGap: 1,
        normalize: true,
      });
      voiceWaveforms.set(waveformId, ws);
    } catch (_) {
      waveformContainer.classList.add('empty');
      waveformContainer.textContent = 'Waveform unavailable for this clip.';
    }
  }
}

function renderStressTimeline(captures) {
  const points = captures
    .filter(c => c.stress != null)
    .sort((a, b) => a.timestamp - b.timestamp);

  const emptyState = document.getElementById('timeline-empty');
  if (!points.length) {
    if (emptyState) emptyState.style.display = 'block';
    if (stressTimelineChart) {
      stressTimelineChart.destroy();
      stressTimelineChart = null;
    }
    return;
  }
  if (emptyState) emptyState.style.display = 'none';

  const labels = points.map(p => p.timestamp.toISOString().slice(11, 19));
  const values = points.map(p => p.stress);
  const canvas = document.getElementById('stress-timeline');
  if (!canvas) return;

  if (stressTimelineChart) {
    stressTimelineChart.data.labels = labels;
    stressTimelineChart.data.datasets[0].data = values;
    stressTimelineChart.update();
    return;
  }

  stressTimelineChart = new Chart(canvas, {
    type: 'line',
    data: {
      labels,
      datasets: [{
        label: 'Stress',
        data: values,
        borderColor: '#f78166',
        backgroundColor: 'rgba(247,129,102,0.18)',
        tension: 0.35,
        fill: true,
        pointRadius: 2,
      }],
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          ticks: { color: '#8b949e', maxTicksLimit: 6 },
          grid: { color: '#21262d' },
        },
        y: {
          min: 0,
          max: 100,
          ticks: { color: '#8b949e', stepSize: 20 },
          grid: { color: '#21262d' },
        },
      },
      plugins: {
        legend: { display: false },
      },
    },
  });
}

// â”€â”€ Main refresh loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function refresh() {
  try {
    const [aisRes] = await Promise.all([
      fetch(AIS_URL),
      fetchVoiceCaptures(),
    ]);

    renderVoiceCaptures();

    if (aisRes.ok) {
      const data = await aisRes.json();
      renderVessels(data.vessels || []);
      document.getElementById('stat-updated').textContent =
        new Date().toISOString().slice(11, 19) + ' UTC';
    }
  } catch (e) {
    console.warn('AIS fetch failed:', e);
  }
}

// Countdown timer
let countdown = REFRESH_MS / 1000;
setInterval(() => {
  countdown--;
  if (countdown <= 0) {
    countdown = REFRESH_MS / 1000;
    refresh();
  }
  document.getElementById('refresh-countdown').textContent =
    `Refresh in ${countdown}s`;
}, 1000);

// Initial load
refresh();
</script>
</body>
</html>
